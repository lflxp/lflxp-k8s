import { toDeferResolveEntry, toDevDependency, toEntry } from '../../util/input.js';
import { isInternal, join } from '../../util/path.js';
import { hasDependency } from '../../util/plugin.js';
const title = 'Karma';
const enablers = ['karma'];
const isEnabled = ({ dependencies }) => hasDependency(dependencies, enablers);
const config = ['karma.conf.js', 'karma.conf.ts', '.config/karma.conf.js', '.config/karma.conf.ts'];
const entry = [];
const resolveConfig = async (localConfig, options) => {
    const inputs = new Set();
    const config = loadConfig(localConfig);
    if (config.frameworks) {
        for (const framework of config.frameworks) {
            inputs.add(toDevDependency(devDepForFramework(framework)));
        }
    }
    if (config.plugins) {
        for (const plugin of config.plugins) {
            if (typeof plugin !== 'string')
                continue;
            if (isInternal(plugin)) {
                inputs.add(toDeferResolveEntry(plugin));
            }
            else {
                inputs.add(toDevDependency(plugin));
            }
        }
    }
    else {
        const karmaPluginDevDeps = Object.keys(options.manifest.devDependencies ?? {}).filter(name => name.startsWith('karma-'));
        for (const karmaPluginDevDep of karmaPluginDevDeps) {
            inputs.add(toDevDependency(karmaPluginDevDep));
        }
    }
    return Array.from(inputs);
};
const devDepForFramework = (framework) => (framework === 'jasmine' ? 'jasmine-core' : framework);
const resolveEntryPaths = (localConfig, options) => {
    const inputs = new Set();
    const config = loadConfig(localConfig);
    const basePath = config.basePath ?? '';
    if (config.files) {
        for (const fileOrPatternObj of config.files) {
            const fileOrPattern = typeof fileOrPatternObj === 'string' ? fileOrPatternObj : fileOrPatternObj.pattern;
            inputs.add(toEntry(join(options.configFileDir, basePath, fileOrPattern)));
        }
    }
    if (config.exclude) {
        for (const fileOrPattern of config.exclude) {
            inputs.add(toEntry(`!${join(options.configFileDir, basePath, fileOrPattern)}`));
        }
    }
    return Array.from(inputs);
};
const loadConfig = (configFile) => {
    const inMemoryConfig = new InMemoryConfig();
    configFile(inMemoryConfig);
    return inMemoryConfig.config ?? {};
};
class InMemoryConfig {
    config;
    set(config) {
        this.config = config;
    }
}
export default {
    title,
    enablers,
    isEnabled,
    config,
    entry,
    resolveConfig,
    resolveEntryPaths,
};
